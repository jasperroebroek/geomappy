import cartopy.crs as ccrs
import matplotlib.axes
import xarray as xr
from cartopy.mpl.geoaxes import GeoAxes
from matplotlib import pyplot as plt
from matplotlib.image import AxesImage

from geomappy.bounds import extent_from_bounds
from geomappy.plot_utils import plot_world
from geomappy.plotting import plot_classified_raster, plot_raster
from geomappy.types import LegendType
from geomappy.utils import add_method, get_cartopy_projection


def _plot_combined_raster(
    classified: bool,
    *,
    da: xr.DataArray,
    ax: matplotlib.axes.Axes | GeoAxes | None = None,
    cartopy: bool = True,
    projection: ccrs.Projection | None = None,
    **kwargs,
) -> tuple[AxesImage, LegendType | None]:
    if da.ndim == 3:
        if da.shape[0] == 1:
            da = da[0]
        elif da.shape[-1] in (3, 4):
            pass
        else:
            raise IndexError(
                'Only 2 or 3 dimensional DataArrays are accepted. 3D DataArrays should have shape (1, y, x) or '
                '(y, x, 3) or (y, x, 4)',
            )

    if da.ndim not in (2, 3):
        raise IndexError('Only 2 or 3 dimensional DataArrays are accepted')

    if isinstance(ax, GeoAxes):
        cartopy = True

    if cartopy:
        if ax is not None:
            crs = ax.projection
        elif 'projection' in kwargs:
            crs = projection
        else:
            crs = da.get_cartopy_projection()
        extent = da.get_extent()
        kwargs['transform'] = crs
        kwargs['extent'] = extent
        subplot_kw = {'projection': crs}

        if ax is None:
            fig, ax = plt.subplots(subplot_kw=subplot_kw)
            ax.set_extent(extent, crs=crs)
    elif ax is None:
        fig, ax = plt.subplots()

    a = da.to_masked_array()

    if classified:
        return plot_classified_raster(a, ax=ax, **kwargs)
    return plot_raster(a, ax=ax, **kwargs)


@add_method('get_cartopy_projection', xr.DataArray)
def da_get_cartopy_projection(self) -> ccrs.CRS:
    return get_cartopy_projection(self.rio.crs)


@add_method('get_extent', xr.DataArray)
def da_get_extent(self) -> tuple[float, float, float, float]:
    return extent_from_bounds(self.rio._internal_bounds())


@add_method('plot_raster', xr.DataArray)
def da_plot_raster(
    self,
    *,
    ax: matplotlib.axes.Axes | None = None,
    cartopy: bool = True,
    **kwargs,
) -> tuple[AxesImage, LegendType | None]:
    """
    Plot raster data from a DataArray using Matplotlib or Cartopy.

    Parameters
    ----------
    self : :class:`xarray.DataArray`
        The DataArray to plot.
    ax : :class:`~matplotlib.axes.Axes`, optional
        Axes to plot on. If None, a new figure and axes are created.
    cartopy : bool, optional
        Whether to use Cartopy. Default is True.
    **kwargs
        Additional keyword arguments passed to `plot_raster`.

    Returns
    -------
    image : :class:`~matplotlib.image.AxesImage`
        The image object representing the raster.
    legend : :class:`~matplotlib.legend.Legend`, :class:`~matplotlib.colorbar.Colorbar`, or None
        Legend or colorbar generated by the plot, if any.
    """
    if self is None:
        return plot_raster(ax=ax, **kwargs)
    if isinstance(self, xr.DataArray):
        return _plot_combined_raster(
            classified=False,
            ax=ax,
            cartopy=cartopy,
            da=self,
            **kwargs,
        )
    raise TypeError('This method does not support positional arguments')


@add_method('plot_classified_raster', xr.DataArray)
def da_plot_classified_raster(
    self,
    *,
    ax: matplotlib.axes.Axes | None = None,
    cartopy: bool = True,
    **kwargs,
) -> tuple[AxesImage, LegendType | None]:
    """
    Plot classified raster data from a DataArray using Matplotlib or Cartopy.

    Parameters
    ----------
    self : :class:`xarray.DataArray`
        The DataArray to plot.
    ax : :class:`~matplotlib.axes.Axes`, optional
        Axes to plot on. If None, a new figure and axes are created.
    cartopy : bool, optional
        Whether to use Cartopy. Default is True.
    **kwargs
        Additional keyword arguments passed to `plot_classified_raster`.

    Returns
    -------
    image : :class:`~matplotlib.image.AxesImage`
        The image object representing the raster.
    legend : :class:`~matplotlib.legend.Legend`, :class:`~matplotlib.colorbar.Colorbar`, or None
        Legend or colorbar generated by the plot, if any.
    """
    if self is None:
        return plot_raster(ax=ax, **kwargs)
    if isinstance(self, xr.DataArray):
        return _plot_combined_raster(
            classified=True,
            ax=ax,
            cartopy=cartopy,
            da=self,
            **kwargs,
        )
    raise TypeError('This method does not support positional arguments')


@add_method('plot_world', xr.DataArray)
def da_plot_world(self) -> GeoAxes:
    """
    Plot the bounding box of a DataArray on a world map.

    Returns
    -------
    :class:`cartopy.mpl.geoaxes.GeoAxes`
        Axes object containing the world map and highlighted bounds.
    """
    bounds = self.rio._internal_bounds()
    return plot_world(bounds, bounds_projection=self.get_cartopy_projection())
