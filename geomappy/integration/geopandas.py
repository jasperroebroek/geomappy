import cartopy.crs as ccrs
import geopandas as gpd
import matplotlib.axes
from cartopy.mpl.geoaxes import GeoAxes
from matplotlib import pyplot as plt
from matplotlib.collections import Collection

from geomappy.bounds import extent_from_bounds
from geomappy.plot_utils import plot_world
from geomappy.plotting import plot_classified_shapes, plot_shapes
from geomappy.types import LegendType
from geomappy.utils import add_method, get_cartopy_projection


def _plot_combined_shapes(
    classified,
    df,
    *,
    ax: matplotlib.axes.Axes | None = None,
    cartopy: bool = True,
    projection: ccrs.Projection | None = None,
    **kwargs,
) -> tuple[list[Collection], LegendType | None]:
    if isinstance(ax, GeoAxes):
        cartopy = True

    if cartopy:
        if ax is not None:
            crs = ax.projection
        elif 'projection' in kwargs:
            crs = projection
        else:
            crs = df.get_cartopy_projection()
        extent = df.get_extent()
        kwargs['transform'] = crs
        if ax is None:
            fig, ax = plt.subplots(subplot_kw={'projection': crs})
            ax.set_extent(extent, crs=crs)
    elif ax is None:
        fig, ax = plt.subplots()

    if classified:
        return plot_classified_shapes(df=df, ax=ax, **kwargs)
    return plot_shapes(df=df, ax=ax, **kwargs)


@add_method('get_extent', gpd.GeoDataFrame, gpd.GeoSeries)
def gpd_get_extent(self) -> tuple[float, float, float, float]:
    return extent_from_bounds(self.total_bounds)


@add_method('get_cartopy_projection', gpd.GeoDataFrame, gpd.GeoSeries)
def gpd_get_cartopy_projection(self) -> ccrs.CRS:
    return get_cartopy_projection(self.crs)


@add_method('plot_shapes', gpd.GeoDataFrame, gpd.GeoSeries)
def gpd_plot_shapes(
    self,
    *,
    ax: matplotlib.axes.Axes | None = None,
    cartopy: bool = True,
    **kwargs,
) -> tuple[list[Collection], LegendType | None]:
    """
    Plot geometries from a GeoDataFrame or GeoSeries using Matplotlib or Cartopy.

    Parameters
    ----------
    self : :class:`geopandas.GeoDataFrame` or :class:`geopandas.GeoSeries`
        The geospatial data to plot.
    ax : :class:`~matplotlib.axes.Axes`, optional
        Axes to plot on. If None, a new figure and axes are created.
    cartopy : bool, optional
        Whether to use Cartopy. Default is True.
    **kwargs
        Additional keyword arguments passed to `plot_shapes`.

    Returns
    -------
    collections : list of :class:`~matplotlib.collections.Collection`
        List of collections for the plotted geometries.
    legend : :class:`~matplotlib.legend.Legend`, :class:`~matplotlib.colorbar.Colorbar`, or None
        Legend or colorbar generated by the plot.
    """
    if self is None:
        return plot_shapes(ax=ax, **kwargs)
    if isinstance(self, gpd.GeoDataFrame):
        return _plot_combined_shapes(
            classified=False,
            ax=ax,
            cartopy=cartopy,
            df=self,
            **kwargs,
        )
    if isinstance(self, gpd.GeoSeries):
        return _plot_combined_shapes(
            classified=False,
            ax=ax,
            cartopy=cartopy,
            df=gpd.GeoDataFrame(self, crs=self.crs),
            **kwargs,
        )
    raise TypeError('This method does not support positional arguments')


@add_method('plot_classified_shapes', gpd.GeoDataFrame, gpd.GeoSeries)
def gpd_plot_classified_shapes(
    self,
    *,
    ax: matplotlib.axes.Axes | None = None,
    cartopy: bool = True,
    **kwargs,
) -> tuple[list[Collection], LegendType | None]:
    """
    Plot classified geometries from a GeoDataFrame or GeoSeries using Matplotlib or Cartopy.

    Parameters
    ----------
    self : :class:`geopandas.GeoDataFrame` or :class:`geopandas.GeoSeries`
        The geospatial data to plot.
    ax : :class:`~matplotlib.axes.Axes`, optional
        Axes to plot on. If None, a new figure and axes are created.
    cartopy : bool, optional
        Whether to use Cartopy for the plot. Default is True.
    **kwargs
        Additional keyword arguments passed to `plot_classified_shapes`.

    Returns
    -------
    collections : list of :class:`~matplotlib.collections.Collection`
        List of collections representing the plotted geometries.
    legend : :class:`~matplotlib.legend.Legend`, :class:`~matplotlib.colorbar.Colorbar`, or None
        Legend or colorbar generated by the plot, if any.
    """
    if self is None:
        return plot_classified_shapes(ax=ax, **kwargs)
    if isinstance(self, gpd.GeoDataFrame):
        return _plot_combined_shapes(
            classified=True,
            ax=ax,
            cartopy=cartopy,
            df=self,
            **kwargs,
        )
    if isinstance(self, gpd.GeoSeries):
        return _plot_combined_shapes(
            classified=True,
            ax=ax,
            cartopy=cartopy,
            df=gpd.GeoDataFrame(self, crs=self.crs),
            **kwargs,
        )
    raise TypeError('This method does not support positional arguments')


@add_method('plot_world', gpd.GeoDataFrame, gpd.GeoSeries)
def gpd_plot_world(self) -> GeoAxes:
    """
    Plots the outer bounds of a GeoDataFrame on a world map.
    """
    bounds = self.total_bounds
    return plot_world(bounds, bounds_projection=self.get_cartopy_projection())
